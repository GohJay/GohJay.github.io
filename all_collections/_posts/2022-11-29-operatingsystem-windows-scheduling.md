---
layout: post 
title: "[OperatingSystem] Windows 스케줄링"
tags: 
categories:
  - OperatingSystem
---

## Intro
스케줄링의 전체적인 개념과 Windows OS의 스케줄링 동작 방식에 대해 알아보자

<br/>

## 1. 스케줄링

 - CPU는 한 번에 하나의 작업만 처리 가능하다. 따라서 운영체제는 여러 프로세스가 존재할 경우, CPU 자원을 적절히 할당하여 프로세스들이 번갈아 가면서 수행될 수 있도록 하여야 하는데 이것을 스케줄링이라 한다.
 - 멀티 스레딩을 지원하는 운영체제에서는 프로세스가 아닌 스레드 단위로 스케줄링을 진행한다.

### 1.1 Context Switching

 - CPU가 어떤 하나의 스레드를 실행하고 있는 상태에서 OS의 스케줄링 요청으로(인터럽트) 인해 다음 스레드가 실행되어야 할 때, 기존의 스레드의 상태 또는 레지스터 값을(Context) 저장하고 CPU가 다음 스레드를 수행할 수 있도록 새로운 스레드의 상태 또는 레지스터 값을(Context) 교체하는 작업을 Context Switching 이라 한다.
 - CPU는 하나의 작업을(최소 단위 오퍼레이션) 마칠 때마다 OS의 인터럽트 요청이 있었는지 확인하고 이를 수행하기 때문에 MOV, CMP와 같은 최소 단위 오퍼레이션의 수행 중간에 Context Switching 되지는 않는다.

![image](https://user-images.githubusercontent.com/51254582/204524197-c5c74744-caf3-4eaf-b681-3c8ef622ef95.png)

 - 멀티 스레드 환경에서 위 그림과 같이 전역 변수 int a 의 값을 ++ 연산하는 상황을 예로 들어보도록 하자.
 - CPU[0] 에서 0이 담긴 a 값을 eax 레지스터에 Load 한 상황에서 Context Switching 되고 CPU[1] 이 a 의 값을 ++ 연산한 후 Store 까지 마친다면, 실제 메모리에는 a 값이 1로 존재하지만 CPU[0] 의 eax 레지스터는 과거의 값 0이 담겨있으므로 ++ 연산은 보장받지 못하게 된다.
 - 이를 해결하기 위해서는 멀티 스레드 환경에서 a와 같은 공유자원을 사용할 때 어느 시점에 하나의 스레드만 공유자원에 접근이 가능하도록 추가적인 코드가 들어가주어야 한다.

<br/>

## 2. Windows 스케줄링 동작 방식

### 2.1 개요

 - 윈도우는 우선순위 기반의 선점형 스케줄링 시스템이다. 따라서 실행중인 스레드는 자신을 실행중인 프로세서 또는 선호된 프로세서에 의해 제한될 수 있다.
 - 스레드가 프로세서에의해 실행되었다면 이 스레드는 퀀텀이라는 시간 동안 실행된다. 퀀텀은 같은 우선순위를 가진 다른 스레드가 돌아가며 실행되기 전까지 이 스레드가 실행되게 허용된 시간이다.
 - 윈도우의 선점형 스케줄링으로 인해 스레드는 퀀텀 시간을 다 소진하지 못할 수도 있다. 더 높은 우선순위의 다른 스레드가 실행할 준비가 되었으면 현재 실행 중인 스레드는 주어진 퀀텀 시간을 마치기 전에 선점 당할 수 있다.
 - 윈도우에서 프로세스는 자기 자신이 수행되는 것이 아니라 스레드가 실행되는 자원과 컨텍스트만 제공하는 것이므로 스케줄링의 단위는 스레드이며, 스케줄링의 결정은 철저히 스레드 기반으로 이루어진다.

### 2.2 스케줄링 시나리오

 - 윈도우는 스케줄링 코드가 커널에 존재하지만 이를 실행시켜주는 별도의 모듈이 존재하지는 않으며, 0번 타이머 인터럽트가 발생될 때마다 스케줄러 인터럽트를 호출시킨다.
 - 호출된 스케줄러는 실질적으로 스레드를 Context Switching 시키지는 않고, 현재 CPU에서 Running 중인 스레드의 퀀텀 타겟을 확인한다. 확인 결과 퀀텀 타겟을 모두 소진하여 Context Switching 되어야 한다고 판단되면 디스패처 인터럽트를 호출시킨다.
 - 호출된 디스패처는 실질적으로 Context Switching 작업을 진행한다. 디스패처는 현재 CPU 코어에서 Running 중인 스레드의 상태를 Ready 상태로 바꾸고, 해당 스레드의 선호도와 우선 순위를 고려하여 어느 CPU 코어에 할당 시킬지 결정한다. 그리고 결정된 CPU 코어의 Ready Queue 에 Context Switching 대상인 스레드의 제어 블록을(TCB) 넣는다. 이런 과정이 끝난 후 현재 CPU의 우선 순위가 가장 높은 Ready Queue에서 스레드 제어 블록을(TCB) 하나 꺼내와 Context 정보를 현재 CPU에 세팅한다.
 - CPU는 그저 레지스터에 세팅되어 있는 정보들을 바탕으로 작업을 실행할 뿐이므로 Context Switching 여부와 관계 없이 계속해서 스레드 작업의 흐름이 진행된다.
