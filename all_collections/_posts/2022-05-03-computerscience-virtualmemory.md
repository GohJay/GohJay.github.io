---
layout: post
title: "[OperatingSystem] 가상메모리와 페이징기법"
tags: 
categories:
  - OperatingSystem
---

## Intro
가상메모리와 페이징기법에 대해 알아보자

<br/>

## 1. 가상메모리

 - 가상메모리란 현대 운영체제가 메모리를 관리하는 기법으로, 각 프로세스에 실제 데이터가 적재되어있는 물리 메모리 주소가 아닌 물리 메모리 주소와 매핑된 가상의 메모리 주소를 주는 방식을 말한다.
 - 이러한 방식은 프로세스에 실제 물리 메모리 크기보다 큰 메모리 영역을 제공할 수 있다는 장점이 있다.
 - 또한 가상메모리 기법을 사용하면 각각의 프로세스는 별도의 가상 메모리 공간을 점유하며, 다른 프로세스의 메모리 공간을 참조할 수 없기 때문에 메모리 보호 측면에서도 장점이 나타난다.
 
<br/>

### 1.1 가상메모리 구조

 - 가상메모리 구조는 크게 Code, Data, Heap, Stack 영역으로 구분 된다.
 
![image](https://user-images.githubusercontent.com/51254582/166413272-04105cdf-5873-4409-8abd-5fc34aafea0a.png)

||`구조`|`설명`|
|---|---|---|
|1|`Code 영역`|사용자가 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 형태로 변환되어 저장되는 공간 <br/> 컴파일 타임에 결정되며 중간에 코드를 바꿀 수 없게 Read-only 속성으로 지정되어있다.|
|2|`Data 영역`|전역변수 또는 정적변수가 저장되는 공간으로 Data영역과 BSS영역으로 나뉜다. <br/> Data 영역: 초기값이 있는 데이터 저장 공간 <br/> BSS영역: 초기값이 없는 데이터 저장 공간|
|3|`Heap 영역`|프로그래머가 필요할 때마다 사용하는 메모리 영역으로 런타임에 결정된다.|
|4|`Stack 영역`|호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를(지역변수, 매개변수, 리턴 값 등) 임시로 저장하는 공간 <br/> 메커니즘은 자료구조 스택과 동일한 LIFO(Last In First Out) 방법을 따른다. <br/> 컴파일 시 Stack 영역의 크기가 결정되기 때문에 무한정 할당 할 수 없다. 따라서 재귀함수가 반복해서 호출되거나, 함수가 지역변수를 Stack 메모리가 초과할 정도로 많이 가지고 있다면 Stack Overflow 에러가 발생한다.|

<br/>

## 2. 페이징기법

 - 페이징 기법이란 프로세스의 가상 메모리 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리 메모리의 서로 다른 위치에 페이지들을 저장하는 방식을 말한다.
 - 페이징 기법을 통해 각 프로세스는 프로세스에서 사용할 가상주소 공간 전체를 물리 메모리에 전부 올려놓고 사용할 필요가 없으며 사용하지 않는 일부는 하드디스크에(**Page Out**), 사용중인 일부는 물리 메모리에(**Page In**) 올려놓고 사용하는 것이 가능하다.

![image](https://user-images.githubusercontent.com/51254582/166415163-c7a95022-70ac-4ca5-ba08-35739efc13f1.png)

 - 페이징 기법에서는 물리 메모리 주소를 가상 메모리 페이지와 동일한 크기의 프레임으로 미리 나누어 둔다. 이는 가상 메모리 페이지와 물리 메모리 프레임의 크기를 동일하게 맞춤으로써 각 프로세스가 빈 프레임이 있으면 어떤 위치든 사용할 수 있기 때문이다.
 - 따라서 모든 프로세스는 각각의 주소 변환을 위한 페이지 테이블을 가지며, 이 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가지고 있게 된다.
 - 페이징 기법에서는 프로세스의 가상주소 공간과 물리주소 공간이 모두 같은 크기의 페이지 단위로 나누어지기 때문에 프로세스가 빈 공간을 어느 곳이든 활용할 수 있으므로 **외부 단편화** 문제가 발생하지 않는다.

<br/>

## 3. 가상메모리에서의 페이지 상태

 - 가상메모리에서의 페이지의 상태는 Free, Reserve, Commit 세 가지로 나뉜다.
 - Free 는 아직 가상 메모리 페이지에 물리 메모리 프레임이 할당 되지 않은 상태를 뜻하고 Commit 은 할당이 완료된 상태를 뜻한다.
 - Reserve 상태를 설명하기 앞서서 프로세스 입장에서 높은 캐시히트율을 고려하여 아직 한번도 접근하지 않는 가상 메모리 주소의 페이지까지 모두 Commit 상태로 확보해버리면 어떻게 될지 먼저 생각해보자
 - .
 - .
 - . 
 - 물리 메모리 공간이 심하게 낭비되므로 이는 다중 처리를 지원하는 우리의 운영체제가 지향하는 바가 아닐 것이다.
 - 따라서 운영체제는 Reserve 상태를 통해 가상 메모리 페이지의 주소 공간을 최초로 접근하기 전 까지는 예약만 해두고 실제 물리 메모리에는 매핑 시키지 않는 방법을 통해 메모리 사용의 효율성을 높이고 있다.
 - CPU가 프로세스에서 Reserve 상태의 페이지에 있는 주소에 최초로 접근하여 **Page Fault** 예외가 발생하면, 이때 운영체제가 예외를 핸들링하여 해당 페이지에 물리 메모리 프레임을 매핑시키고 페이지 상태를 Commit 으로 변경한다.

||`가상메모리 상태`|`의미`|
|---|---|---|
|1|`Free`|할당되지 않음|
|2|`Reserve`|예약완료 (최소 단위 : 64KB)|
|3|`Commit`|할당완료 (최소 단위 : 4KB)|
